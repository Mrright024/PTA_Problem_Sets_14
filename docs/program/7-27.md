# 7-27 冒泡法排序

将$N$个整数按从小到大排序的冒泡排序法是这样工作的：从头到尾比较相邻两个元素，如果前面的元素大于其紧随的后面元素，则交换它们。通过一遍扫描，则最后一个元素必定是最大的元素。然后用同样的方法对前$N−1$个元素进行第二遍扫描。依此类推，最后只需处理两个元素，就完成了对$N$个数的排序。

本题要求对任意给定的$K$（<$N$），输出扫描完第$K$遍后的中间结果数列。

## 输入格式

输入在第1行中给出$N$和$K$（$1\leq K<N\leq 100$），在第2行中给出$N$个待排序的整数，数字间以空格分隔。

## 输出格式

在一行中输出冒泡排序法扫描完第$K$遍后的中间结果数列，数字间以空格分隔，但末尾不得有多余空格。

## 输入样例

```c
6 2
2 3 5 1 6 4
```

## 输出样例

```c
2 1 3 4 5 6
```

## 分析与答案

标准的冒泡，将外层的循环次数换成$K$​，并使用指针来创建动态数组。

还以为这道题会卡冒泡排序的$O(n^2)$带来的超时问题，结果真的就是冒泡……

```c
#include <stdio.h>
#include <stdlib.h>

int main(){
    int n=0,k=0;
    scanf("%d %d",&n,&k);
    int * arr = (int*)malloc(n*sizeof(int));
    int i,j,tmp;
    for(i=0;i<n;i++){
        scanf("%d",arr+i);
    }
    for(j=1;j<=k;j++){
        for(i=0;i<n-1;i++){
            if(*(arr+i)>*(arr+(i+1))){
               tmp = *(arr+i);
               *(arr+i)=*(arr+(i+1));
               *(arr+(i+1))=tmp; 
            }
        }
    }
    for(i=0;i<n;i++){
        printf("%d",*(arr+i));
        if(i!=n-1)
            printf(" ");
    }
    return 0;
}
```

![7-27 测试点](https://picb.waku.icu/picb/2024/05/13/202405132128423.png)